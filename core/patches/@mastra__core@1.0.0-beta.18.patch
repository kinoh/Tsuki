--- a/dist/chunk-GFALVOBW.cjs
+++ b/dist/chunk-GFALVOBW.cjs
@@ -10554,36 +10554,54 @@
     }
     switch (chunk.type) {
       case "response-metadata":
         runState.setState({
           responseMetadata: {
             id: chunk.payload.id,
             timestamp: chunk.payload.timestamp,
             modelId: chunk.payload.modelId,
             headers: chunk.payload.headers
           }
         });
         break;
+      case "text-start": {
+        runState.setState({
+          providerOptions: chunk.payload.providerMetadata ?? runState.state.providerOptions
+        });
+        if (isControllerOpen(controller)) {
+          controller.enqueue(chunk);
+        }
+        break;
+      }
       case "text-delta": {
         const textDeltasFromState = runState.state.textDeltas;
         textDeltasFromState.push(chunk.payload.text);
         runState.setState({
           textDeltas: textDeltasFromState,
           isStreaming: true
         });
         if (isControllerOpen(controller)) {
           controller.enqueue(chunk);
         }
         break;
       }
+      case "text-end": {
+        runState.setState({
+          providerOptions: chunk.payload.providerMetadata ?? runState.state.providerOptions
+        });
+        if (isControllerOpen(controller)) {
+          controller.enqueue(chunk);
+        }
+        break;
+      }
       case "tool-call-input-streaming-start": {
         const tool2 = tools?.[chunk.payload.toolName] || Object.values(tools || {})?.find((tool3) => `id` in tool3 && tool3.id === chunk.payload.toolName);
         if (tool2 && "onInputStart" in tool2) {
           try {
             await tool2?.onInputStart?.({
               toolCallId: chunk.payload.toolCallId,
               messages: messageList.get.input.aiV5.model(),
               abortSignal: options?.abortSignal
             });
           } catch (error2) {
             logger?.error("Error calling onInputStart", error2);
           }
@@ -10538,7 +10538,29 @@
-    if (chunk.type !== "reasoning-start" && chunk.type !== "reasoning-delta" && chunk.type !== "reasoning-end" && chunk.type !== "redacted-reasoning" && chunk.type !== "reasoning-signature" && chunk.type !== "response-metadata" && runState.state.isReasoning) {
-      runState.setState({
-        isReasoning: false,
-        reasoningDeltas: []
-      });
-    }
+    if (chunk.type !== "reasoning-start" && chunk.type !== "reasoning-delta" && chunk.type !== "reasoning-end" && chunk.type !== "redacted-reasoning" && chunk.type !== "reasoning-signature" && chunk.type !== "response-metadata" && runState.state.isReasoning) {
+      const providerMetadata = runState.state.providerOptions;
+      if (providerMetadata || runState.state.reasoningDeltas.length > 0) {
+        const message = {
+          id: messageId,
+          role: "assistant",
+          content: {
+            format: 2,
+            parts: [
+              {
+                type: "reasoning",
+                reasoning: "",
+                details: [{ type: "text", text: runState.state.reasoningDeltas.join("") }],
+                ...providerMetadata ? { providerMetadata } : {}
+              }
+            ]
+          },
+          createdAt: /* @__PURE__ */ new Date()
+        };
+        messageList.add(message, "response");
+      }
+      runState.setState({
+        isReasoning: false,
+        reasoningDeltas: [],
+        providerOptions: void 0
+      });
+    }
@@ -10684,6 +10706,13 @@
       case "reasoning-end": {
+        if (!runState.state.isReasoning && runState.state.reasoningDeltas.length === 0 && !runState.state.providerOptions) {
+          if (isControllerOpen(controller)) {
+            controller.enqueue(chunk);
+          }
+          break;
+        }
         const message = {
           id: messageId,
           role: "assistant",
           content: {
             format: 2,
             parts: [
               {
                 type: "reasoning",
                 reasoning: "",
                 details: [{ type: "text", text: runState.state.reasoningDeltas.join("") }],
                 providerMetadata: chunk.payload.providerMetadata ?? runState.state.providerOptions
               }
             ]
           },
           createdAt: /* @__PURE__ */ new Date()
         };
         messageList.add(message, "response");
         runState.setState({
           isReasoning: false,
           reasoningDeltas: [],
           providerOptions: void 0
         });
         if (isControllerOpen(controller)) {
           controller.enqueue(chunk);
         }
         break;
       }
--- a/dist/chunk-2XX35XRX.js
+++ b/dist/chunk-2XX35XRX.js
@@ -10526,36 +10526,54 @@
     }
     switch (chunk.type) {
       case "response-metadata":
         runState.setState({
           responseMetadata: {
             id: chunk.payload.id,
             timestamp: chunk.payload.timestamp,
             modelId: chunk.payload.modelId,
             headers: chunk.payload.headers
           }
         });
         break;
+      case "text-start": {
+        runState.setState({
+          providerOptions: chunk.payload.providerMetadata ?? runState.state.providerOptions
+        });
+        if (isControllerOpen(controller)) {
+          controller.enqueue(chunk);
+        }
+        break;
+      }
       case "text-delta": {
         const textDeltasFromState = runState.state.textDeltas;
         textDeltasFromState.push(chunk.payload.text);
         runState.setState({
           textDeltas: textDeltasFromState,
           isStreaming: true
         });
         if (isControllerOpen(controller)) {
           controller.enqueue(chunk);
         }
         break;
       }
+      case "text-end": {
+        runState.setState({
+          providerOptions: chunk.payload.providerMetadata ?? runState.state.providerOptions
+        });
+        if (isControllerOpen(controller)) {
+          controller.enqueue(chunk);
+        }
+        break;
+      }
       case "tool-call-input-streaming-start": {
         const tool2 = tools?.[chunk.payload.toolName] || Object.values(tools || {})?.find((tool3) => `id` in tool3 && tool3.id === chunk.payload.toolName);
         if (tool2 && "onInputStart" in tool2) {
           try {
             await tool2?.onInputStart?.({
               toolCallId: chunk.payload.toolCallId,
               messages: messageList.get.input.aiV5.model(),
               abortSignal: options?.abortSignal
             });
           } catch (error2) {
             logger?.error("Error calling onInputStart", error2);
           }

@@ -10510,7 +10510,29 @@
-    if (chunk.type !== "reasoning-start" && chunk.type !== "reasoning-delta" && chunk.type !== "reasoning-end" && chunk.type !== "redacted-reasoning" && chunk.type !== "reasoning-signature" && chunk.type !== "response-metadata" && runState.state.isReasoning) {
-      runState.setState({
-        isReasoning: false,
-        reasoningDeltas: []
-      });
-    }
+    if (chunk.type !== "reasoning-start" && chunk.type !== "reasoning-delta" && chunk.type !== "reasoning-end" && chunk.type !== "redacted-reasoning" && chunk.type !== "reasoning-signature" && chunk.type !== "response-metadata" && runState.state.isReasoning) {
+      const providerMetadata = runState.state.providerOptions;
+      if (providerMetadata || runState.state.reasoningDeltas.length > 0) {
+        const message = {
+          id: messageId,
+          role: "assistant",
+          content: {
+            format: 2,
+            parts: [
+              {
+                type: "reasoning",
+                reasoning: "",
+                details: [{ type: "text", text: runState.state.reasoningDeltas.join("") }],
+                ...providerMetadata ? { providerMetadata } : {}
+              }
+            ]
+          },
+          createdAt: /* @__PURE__ */ new Date()
+        };
+        messageList.add(message, "response");
+      }
+      runState.setState({
+        isReasoning: false,
+        reasoningDeltas: [],
+        providerOptions: void 0
+      });
+    }
@@ -10652,6 +10674,13 @@
       case "reasoning-end": {
+        if (!runState.state.isReasoning && runState.state.reasoningDeltas.length === 0 && !runState.state.providerOptions) {
+          if (isControllerOpen(controller)) {
+            controller.enqueue(chunk);
+          }
+          break;
+        }
         const message = {
           id: messageId,
           role: "assistant",
           content: {
             format: 2,
             parts: [
               {
                 type: "reasoning",
                 reasoning: "",
                 details: [{ type: "text", text: runState.state.reasoningDeltas.join("") }],
                 providerMetadata: chunk.payload.providerMetadata ?? runState.state.providerOptions
               }
             ]
           },
           createdAt: /* @__PURE__ */ new Date()
         };
         messageList.add(message, "response");
         runState.setState({
           isReasoning: false,
           reasoningDeltas: [],
           providerOptions: void 0
         });
         if (isControllerOpen(controller)) {
           controller.enqueue(chunk);
         }
         break;
       }
